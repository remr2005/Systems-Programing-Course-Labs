mvi b, 05h
mvi c, 00h
lxi h, ARRAY1
lxi d, ARRAY2
lxi sp, 1000h

; Оформил в цикл
LOOP1:
   push b
   mvi c, 0h
   
   mov a, m; A = a1
   mov b, a
   
   ani 80h ; Достаю знак элемента массива
   ora c
   mov c, a
   
   xchg
   mov a, m
   ani 80h ; Достаю знак второго элемента массива
   rrc ; Т.к есть жесткое ограничение по использованию памяти использую первые 3 старших бита регистра С
   ora c ; Как знак первого числа, знак второго числа, знак результата из этого я пойму есть ли переполнение или нет
   mov c, a

   mov a, b
   sub m
   mov m, a ; Вычилсяю сам результат и помещаю его обратно в ОЗУ

   ani 80h ; Достаю знак результата
   rrc
   rrc
   ora c
   mov c, a

   xri 80h ; Переполнение происходит в двух случаях, когда при сложении оба числа отрицательные, а ответ положительный и наоборот
   jz SKIP ; То есть 110 и 001 это случаи переполнения, так как тут вычитание второй бит инвертируется
           ; То есть 100 и 011, то есть если регистр С равен 10000000(80h) или 01100000(60h) то произошло переполнение

   mov c, a
   xri 60h
   jz SKIP

   jmp next_loop ; если переполнения нет, то просто переходим на следующий цикл
   
   SKIP: ; если переполнение есть то увеличивваем счетчик переполнений
   pop b
   inr c
   jmp skip_2

   next_loop:
   pop b
   skip_2:
   xchg
   inx h
   inx d
   dcr b
   JNZ LOOP1

lxi h, ARRAY2
mvi b, 04
mov a, m 
inx h


LOOP2:
    mov d, m
    mov e, a

    ani 80h ; Записываю итоговый знак при умножении в первый бит регистра  С
    ora c
    mov c, a 
    mov a, d
    ani 80h
    ora c
    mov c, a
    mov a, e
    

    ani 80H ; Модуль E
    mov a, e
    jz skip_inv_1
    xri ffh
    inr a
    mov e, a
    skip_inv_1:

    mov a, d
    ani 80H ; Модуль D
    mov a, d
    jz skip_inv_2
    xri ffh
    inr a
    mov d, a
    skip_inv_2:
    
    mvi a, 0;путем циклического сложения
    MUL_LOOP:
    add D
    dcr E
    JNZ MUL_LOOP

    mov e, a; Проверка на знаковое переполнение
    ani 80h
    jz skip_inr_c
    inr c

    skip_inr_c:
    mov a, c; Присваивание результату корректного знака при умножении
    ani 80h
    jz skip_chg ;  Если первый бит С равен 0(С положительное) то пропускаем изменение знака результата
    mov a, e ; Иначе делаем результат отрицательным
    ori 80h
    mov e, a

    skip_chg: ; Делаем С пололжительным для следующего цикла
    mov a, c
    ani 7Fh
    mov c, a

    mov a, e ;  Переходим к следующему элемеенту массива 
    inx h
    dcr b
    jnz LOOP2

hlt
; Добавил нули в промежутках чтобы было удобнее их разделять в ОЗУ
DB 0H
DB 0H
ARRAY1:
    DB 02H, 03H, 04H, 05H, 06H

DB 0H
DB 0H
ARRAY2:
    DB ffH, 02H, 01H, 01H, 01H
DB 0H
DB 0H